#include <vector>
#include "assert.h"
#include "Core\Math\Vector2D.h"
#include "GameCommon\PhysicsInfo.h"
#include "Core\Utility\Utility.h"
#include "EngineHigh\CollisionSystem\CollisionDetection.h"
#include "EngineHigh\CollisionSystem\CollisionPair.h"

namespace Physics {
	void updateFrameVelocity(vector<PhysicsInfo> &o_physicsInfos) {
		size_t numOfObjects = o_physicsInfos.size();
		for (size_t i = 0; i < numOfObjects; i++) {
			o_physicsInfos[i].frameVelocity = o_physicsInfos[i].velocity;
		}

	}
	void updateVelocity(PhysicsInfo & o_physicsInfo, float i_dt) {
		SmartPtr<GameObject> temp_Object = o_physicsInfo.getGameObject().Aquire();
		assert(temp_Object != nullptr);
		
		Vector2D startVelocity = o_physicsInfo.velocity;//backup start velocity
		float value_Velocity = (float)o_physicsInfo.getVelocity().getMagnitude();
		float value_Drag_Force = value_Velocity * value_Velocity * o_physicsInfo.getDrag();
		Vector2D dragForece(0, 0);
		if (value_Velocity != 0) {
			float temp_Ratio = value_Drag_Force / value_Velocity;
			dragForece.set_x(-1 * temp_Ratio * o_physicsInfo.getVelocity().get_x());
			dragForece.set_y(-1 * temp_Ratio * o_physicsInfo.getVelocity().get_y());
		}
		assert(o_physicsInfo.getMass());
		Vector2D acceleration = dragForece * (1 / o_physicsInfo.getMass());
		Vector2D temp_Velocity = o_physicsInfo.getVelocity() + acceleration * i_dt;//calculate velocity generated by drag
		if (temp_Velocity.get_x() *  o_physicsInfo.getVelocity().get_x() <= 0 && temp_Velocity.get_y() *  o_physicsInfo.getVelocity().get_y() <= 0) {
			o_physicsInfo.velocity = Vector2D(0, 0);//set velocity after drag
		}
		else {
			o_physicsInfo.velocity = o_physicsInfo.velocity + acceleration * i_dt;//set velocity after drag
		}

		acceleration = o_physicsInfo.forcedApplied * (1 / o_physicsInfo.getMass());//calculate acceleration generated by all the rest forces
		o_physicsInfo.velocity = o_physicsInfo.velocity + acceleration * i_dt;
		o_physicsInfo.frameVelocity = (startVelocity + o_physicsInfo.velocity) * 0.5;
	}

	void moveObjectsForward(vector<PhysicsInfo> &o_physicsInfos, float timeSpan) {
		size_t numOfObjects = o_physicsInfos.size();
		for (size_t i = 0; i < numOfObjects; i++) {
			SmartPtr<GameObject> temp_Object = o_physicsInfos[i].getGameObject().Aquire();
			temp_Object->position = temp_Object->position + o_physicsInfos[i].frameVelocity * timeSpan;
		}
	}

	void resolveCollision(collisionPair &o_earliestCollision) {
		Vector4D normal_A;
		Vector4D normal_B;
		normal_A = o_earliestCollision.collisionNormal4A;
		normal_B = -1 * normal_A;
		
		Vector2D normal2D_A(normal_A.x, normal_A.y);
		Vector2D v_reflectedA = abs(dot(-2 * o_earliestCollision.collisionObjects[0]->frameVelocity, normal2D_A)) * normal2D_A - (-1 * o_earliestCollision.collisionObjects[0]->frameVelocity);
		o_earliestCollision.collisionObjects[0]->frameVelocity = v_reflectedA;
		o_earliestCollision.collisionObjects[0]->velocity = o_earliestCollision.collisionObjects[0]->frameVelocity;
		//DEBUG_PRINT_INFO("x = %f, y = %f", o_earliestCollision.collisionObjects[0]->frameVelocity.x, o_earliestCollision.collisionObjects[0]->frameVelocity.y);

		Vector2D normal2D_B(normal_B.x, normal_B.y);
		Vector2D v_reflectedB = abs(dot(-2 * o_earliestCollision.collisionObjects[1]->frameVelocity, normal2D_B)) * normal2D_B - (-1 * o_earliestCollision.collisionObjects[1]->frameVelocity);
		o_earliestCollision.collisionObjects[1]->frameVelocity = v_reflectedB;
		o_earliestCollision.collisionObjects[1]->velocity = o_earliestCollision.collisionObjects[1]->frameVelocity;
	}

	void updateAllObjects(vector<PhysicsInfo> & o_physicsInfos, float i_dt) {
		float frameTime = i_dt;
		
		size_t numOfObjects = o_physicsInfos.size();
		for (size_t i = 0; i < numOfObjects; i++) {
			updateVelocity(o_physicsInfos[i], i_dt);
			//DEBUG_PRINT_INFO("x = %f, y = %f", o_physicsInfos[i].frameVelocity.x, o_physicsInfos[i].frameVelocity.y);
		}

		while (frameTime > 0) {
			collisionPair earliestCollision;
			if (Engine::findEarliestCollision(o_physicsInfos, frameTime, earliestCollision)) {
				moveObjectsForward(o_physicsInfos, earliestCollision.collisionTime);
				//DEBUG_PRINT_INFO("collision time: %f", earliestCollision.collisionTime);
				resolveCollision(earliestCollision);
				frameTime = frameTime - earliestCollision.collisionTime;
			}

			else {
				moveObjectsForward(o_physicsInfos, earliestCollision.collisionTime);
				frameTime = 0;
			}
			
		}
	}
}